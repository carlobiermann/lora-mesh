/* 
Sources at:
https://github.com/carlobiermann/lora-mesh/tree/main/02_random_data_to_db#sources
*/

#include <SPI.h>              
#include <LoRa.h>

// LoRa Chip Semtech SX1278 pins
#define SCK     5    // GPIO5  -- 
#define MISO    19   
#define MOSI    27   

// More LoRa Chip pins?
#define RADIO_CS_PIN 18
#define RADIO_DI0_PIN 26
#define RADIO_RST_PIN 14

// LoRa EU Frequency
const long frequency = 868E6;  

byte localAddress = 0x22;
byte destinationAddress = 0xAA;

// msgTypes A-E in HEX ASCII
int i = 0;
byte types[8] = {0x41, 0x42, 0x43, 0x44, 0x45, 0x40, 0x46, 0x47};

static byte msgPayload[24] = "";

// INIT
void setup() {
  Serial.begin(9600);                   
  while (!Serial);

  SPI.begin(SCK,MISO,MOSI,RADIO_CS_PIN);
  LoRa.setPins(RADIO_CS_PIN, RADIO_RST_PIN, RADIO_DI0_PIN);

  if (!LoRa.begin(frequency)) {
    Serial.println("LoRa init failed. Check your connections.");
    while (true);                       // if failed, do nothing
  }
  LoRa.enableCrc();
}

// MAIN LOOP
void loop() {  
  if (runEvery(3000)) {
    generatePayload();
    LoRa_sendPacket(types[i]);
    i++;
    if (i > 7) {
      i = 0;
    }
  }
}

// FUNCTIONS

void printDouble( double val, unsigned int precision){
// prints val with number of decimal places determine by precision
// NOTE: precision is 1 followed by the number of zeros for the desired number of decimial places
// example: printDouble( 3.1415, 100); // prints 3.14 (two decimal places)

   Serial.print (int(val));  //prints the int part
   Serial.print("."); // print the decimal point
   unsigned int frac;
   if(val >= 0)
     frac = (val - int(val)) * precision;
   else
      frac = (int(val)- val ) * precision;
   int frac1 = frac;
   while( frac1 /= 10 )
       precision /= 10;
   precision /= 10;
   while(  precision /= 10)
       Serial.print("0");

   Serial.println(frac,DEC) ;
}

void generatePayload(){
  
  int nodeId = random(1, 9);
  int hops = random(0,4);    
  int iLat = random(52500000, 52530000);
  int iLon = random(13200000, 13600000);
  double lat = iLat;
  double lon = iLon;
  lat = lat/1000000;
  lon = lon/1000000;

  /*
  Serial.println("Random node data:");
  Serial.println(nodeId);
  Serial.println(hops);
  printDouble(lat, 10000000);
  printDouble(lon, 10000000);
  */

  // convert to raw byte array
  memcpy(&msgPayload[0], (uint8_t *) &nodeId, sizeof(nodeId));
  memcpy(&msgPayload[4], (uint8_t *) &hops, sizeof(hops));
  memcpy(&msgPayload[8], (uint8_t *) &lat, sizeof(lat));
  memcpy(&msgPayload[16], (uint8_t *) &lon, sizeof(lon));

  /* 
  Serial.println("Generated byte array: ");
  for (int i=0; i<=23; i++) {
    Serial.println(msgPayload[i], HEX);
  }
  */
}


void LoRa_sendPacket(byte msgType) {

  switch (msgType) {

    // Type A: BROADCAST from GW
    case 0x41:
      Serial.println("Sending msgType A...");
      LoRa.beginPacket();          
      LoRa.write(0x41);           // msgType 
      LoRa.write(0xFF);           // recipient, simulating BROADCAST from LNs
      LoRa.write(0xAA);           // sender, simulating GW address 0xAA
      LoRa.write(0x00);           // router, set to 0x00 bc it's a BROADCAST
      LoRa.write(0xAA);           // source is still GW (simulated)
      LoRa.write(0x00);           // sizePayload, set to 0x00 bc no payload to transmit
      LoRa.endPacket(true);
      break;

    // Type B: Direct GW msg from other LN  
    case 0x42:
      Serial.println("Sending msgType B...");
      LoRa.beginPacket();
      LoRa.write(0x42);           // msgType 
      LoRa.write(0xAA);           // recipient GW
      LoRa.write(localAddress);   // sender, simulating GW address 0xAA
      LoRa.write(0x00);           // router, set to 0x00 bc it's a BROADCAST
      LoRa.write(localAddress);   // source is still localAddress (simulated)
      LoRa.write(24);             // sizePayload
      LoRa.write(msgPayload, 24); // payload         
      LoRa.endPacket(true);
      break;

    // Type C: GW ACK  
    case 0x43:
      Serial.println("Sending msgType C...");
      LoRa.beginPacket();
      LoRa.write(0x43);           // msgType 
      LoRa.write(0x11);           // recipient 0x11
      LoRa.write(0xAA);           // sender, simulating GW address 0xAA
      LoRa.write(0x00);           // router, set to 0x00 bc it's a BROADCAST
      LoRa.write(0xAA);           // source is still GW (simulated)
      LoRa.write(0x00);           // sizePayload, set to 0x00 bc no payload to transmit      
      LoRa.endPacket(true);
      break;

    // Type D: BROADCASTS from other LNs  
    case 0x44:
      Serial.println("Sending msgType D...");
      LoRa.beginPacket();
      LoRa.write(0x44);           // msgType 
      LoRa.write(0xFF);           // recipient, simulating BROADCAST from LNs
      LoRa.write(localAddress);   // sender, simulating GW address 0xAA
      LoRa.write(0x00);           // router, set to 0x00 bc it's a BROADCAST
      LoRa.write(localAddress);   // source is still localAddres (simulated)
      LoRa.write(1);              // sizePayload 
      LoRa.write(3);              // payload, number of GWhops    
      LoRa.endPacket(true);
      break;

    // Type E: Msg to route
    case 0x45:
      Serial.println("Sending msgType E...");
      LoRa.beginPacket();
      LoRa.write(0x45);           // msgType 
      LoRa.write(0xAA);           // recipient, GW
      LoRa.write(localAddress);   // sender, localAddress
      LoRa.write(0x11);           // router, set to 0x11
      LoRa.write(localAddress);   // source, localAddress
      LoRa.write(24);             // sizePayload
      LoRa.write(msgPayload, 24); // payload  
      LoRa.endPacket(true);
      break;  

    // THROW ERROR: "msgType not found..."
    case 0x40:
      Serial.println("Sending unknown msgType ...");
      LoRa.beginPacket();
      LoRa.write(0x40);           // msgType 
      LoRa.write(0xAA);           // recipient, GW
      LoRa.write(localAddress);   // sender, localAddress
      LoRa.write(0x11);           // router, set to 0x11
      LoRa.write(localAddress);   // source, localAddress
      LoRa.write(24);             // sizePayload
      LoRa.write(msgPayload, 24); // payload  
      LoRa.endPacket(true);
      break;   

    // THROW ERROR: "msgType not found..."
    case 0x46:
      Serial.println("Sending unknown msgType...");
      LoRa.beginPacket();
      LoRa.write(0x46);           // msgType 
      LoRa.write(0xAA);           // recipient, GW
      LoRa.write(localAddress);   // sender, localAddress
      LoRa.write(0x11);           // router, set to 0x11
      LoRa.write(localAddress);   // source, localAddress
      LoRa.write(24);             // sizePayload
      LoRa.write(msgPayload, 24); // payload  
      LoRa.endPacket(true);
      break;  

      // THROW ERROR: "Packet too large..."
      case 0x47:
      Serial.println("Sending packet that's too large...");
      LoRa.beginPacket();
      LoRa.write(0x47);           // msgType 
      LoRa.write(0xAA);           // recipient, GW
      LoRa.write(localAddress);   // sender, localAddress
      LoRa.write(0x11);           // router, set to 0x11
      LoRa.write(localAddress);   // source, localAddress
      LoRa.write(24);             // sizePayload
      LoRa.write(msgPayload, 24); // payload  
      LoRa.write(1);              // one byte extra --> packetSize = 31 instead of 30
      LoRa.endPacket(true);
      break;  
  }
}


boolean runEvery(unsigned long interval) {
  static unsigned long previousMillis = 0;
  unsigned long currentMillis = millis();
  if (currentMillis - previousMillis >= interval)
  {
    previousMillis = currentMillis;
    return true;
  }
  return false;
}


/*
  // Print ACK
  for(int i = 0; i <= 3; i++) {
     Serial.println(loraMessage[i], HEX);
  }

*/
